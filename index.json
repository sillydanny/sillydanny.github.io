[{"content":"Configuring VLANs on a Host for Proxmox VE In today\u0026rsquo;s increasingly complex networking environments, Virtual Local Area Networks (VLANs) have become a crucial tool for managing network traffic and ensuring optimal performance.\nThis blog post provides a step-by-step guide on configuring VLANs on a host for Proxmox Virtual Environment (VE), a popular open-source virtualization platform.\nWhy use VLANs with Proxmox VE? VLANs allow you to segregate network traffic into isolated broadcast domains, improving security and reducing network congestion. By configuring VLANs on a Proxmox VE host, you can:\nImprove network performance by reducing broadcast traffic. Enhance security by isolating sensitive virtual machines (VMs) and containers. Simplify network management and troubleshooting. Prerequisites Before proceeding, ensure you have the following:\nA Proxmox VE host installed and configured. A managed network switch that supports VLAN tagging (IEEE 802.1Q). Procedures: This guide provides procedures for configuring VLANs on a host for Proxmox Virtual Environment (VE).\nThis guide provides instructions for configuring VLANs, with separate sections for both the command line interface (CLI) and the graphical user interface (GUI).\nThe Command Line Interface (CLI) Configuration Step 1: A Proxmox VE host configurration Edit configuration file for the VLAN interface in /etc/network/interfaces.\n1 vi /etc/network/interfaces The eno1 is a physical network interface and vmbr0 is a Linux Bridge.\nthe following configuration, adjusting the address and gateway parameters as needed\nUse VLAN 2 for the Proxmox VE management IP with VLAN aware Linux bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 auto lo iface lo inet loopback iface eno1 inet manual auto vmbr0.2 iface vmbr0.2 inet static address 10.2.2.254/24 gateway 10.2.2.1 auto vmbr0 iface vmbr0 inet static bridge-ports eno1 bridge-stp off bridge-fd 0 bridge-vlan-aware yes bridge-vids 1-4094 Save the file and exit the editor use :wq\nApply the new configuration by restarting the networking service:\n1 systemctl restart networking Step2: Configure a managed Network Switch In this scenario, use Cisco SG300-10P 10-Port Gigabit Managed Switch.\nThe command \u0026ldquo;enable\u0026rdquo; is used to enter privileged EXEC mode on a Cisco SG300-10 switch, which allows access to configuration and management commands.\n1 enable The subsequent command \u0026ldquo;configuration terminal\u0026rdquo; is used to enter global configuration mode, which allows the user to configure various aspects of the switch\u0026rsquo;s behavior.\n1 configuration terminal The command \u0026ldquo;interface gigabitethernet2\u0026rdquo; is used to select the Gigabit Ethernet interface 2 on the switch for configuration.\nThe command \u0026ldquo;description VMS01\u0026rdquo; is used to assign a description to the selected interface, in this case labeling it as \u0026ldquo;VMS01\u0026rdquo;, which standard for Virtual Machine Server.\nThe command \u0026ldquo;switchport trunk allowed vlan add 2-4,11\u0026rdquo; is used to configure the selected interface as a trunk port and allow traffic from VLANs 2, 3, 4, and 11 to pass through the port. The \u0026ldquo;add\u0026rdquo; keyword specifies that these VLANs should be added to the existing list of allowed VLANs, if any.\n1 2 3 interface gigabitethernet2 description VMS01 switchport trunk allowed vlan add 2-4,11 Step 3: Assign VLAN to VMs or Containers Finally, assign the newly created bridge to your VMs or containers:\nThis sample use container.\nSelect the desired container in the Proxmox VE web interface. Go to the Network tab. Click Edit. Select the bridge (e.g., vmbr0) from the Bridge dropdown menu. Assign a vlan number in VLAN Tag Click OK to apply the changes. Repeat these steps for each container you want to assign to the VLAN.\nno VLAN as PVID vlan1\nGraphical User Interface (GUI) Configuration Step 1: Configure Proxmox VE Network Now, create a new Linux Bridge or Open vSwitch in the Proxmox VE web interface:\nLog in to the Proxmox VE web interface. Go to Datacenter \u0026gt; vms02 (your-node) \u0026gt; System \u0026gt; Network. Click \u0026ldquo;Create \u0026gt; Linux Bridge\u0026rdquo; or \u0026quot; Edit the Existing vmbr0 of Linux Bridge\u0026quot; (depending on your preference). Add the VLAN interface to the Bridge ports field. Step2: Configure a managed Network Switch PVID (Default Vlan ID) as 1\nConfigure the GE2 interface as a Trunk port and allow traffic from VLANs 2, 3, 4, and 11 to pass through the port, with VLAN1 as the Default Vlan without Vlan Tag.\nConclusion By following this guide, you\u0026rsquo;ve successfully configured VLANs on a Proxmox VE host and assigned them to your VMs and containers. This will help you optimize network performance, enhance security, and simplify network management in your virtual environment.\nReference: https://pve.proxmox.com/wiki/Network_Configuration Related: Proxmox VE 01 - 系統安裝篇 遷移 VMware ESXi 的 ova 文件到 Proxmox 7.0 PVE 的 LXC 容器系統安裝 CUPS 軟件，實現多平台共享的印表機 PVE (Proxmox VE) 多網口的識別 Proxmox VE 7 安裝Home Assistant虛擬機系統 Managing LXC in Proxmox Virtual Environment (PVE) 在 Ubuntu 中設置 VLAN ","permalink":"https://blog.kingtam.cf/posts/pve-host-vlan/","summary":"Configuring VLANs on a Host for Proxmox VE In today\u0026rsquo;s increasingly complex networking environments, Virtual Local Area Networks (VLANs) have become a crucial tool for managing network traffic and ensuring optimal performance.\nThis blog post provides a step-by-step guide on configuring VLANs on a host for Proxmox Virtual Environment (VE), a popular open-source virtualization platform.\nWhy use VLANs with Proxmox VE? VLANs allow you to segregate network traffic into isolated broadcast domains, improving security and reducing network congestion.","title":"Configuring VLANs on a Host for PVE (Proxmox VE)"},{"content":"PVE (Proxmox VE) Multi-port Identification About: This is a post about network card (multiple ports) identification in the PVE system. Through the ethtool command, you can easily find the corresponding location of each network port.\nOperation Steps: Take Intel EXPI9402PTBLK 82571GB Network Adapter as an example\nInstall the ethtool command\n1 apt update \u0026amp;\u0026amp; apt install ethtool -y ethtool can be used to view network device driver parameters and hardware configuration.\nCheck the device name of the network card in the PVE server\n1 ip -c a Where enp1s0f0 and enp1s0f1 are the two network ports of the network card, corresponding to MAC addresses 00:24:81:7e:ce:cb and 00:24:81:7e:ce:ca respectively.\nMethod A Use ethtool to identify the device name and corresponding network port location in the PVE system.\nEnter the following command to find the physical network port (network port with indicator) of the first device name enp1s0f0\n1 ethtool --identify enp1s0f0 Enter the following command to find the physical network port (network port with indicator) of the second device name enp1s0f1\n1 ethtool --identify enp1s0f1 Method B If the network card does not support the ethtool --identify command (indicator) for identification, the following method can be used.\nEnable the two network ports enp1s0f0 and enp1s0f1 separately\n1 2 ifup enp1s0f0 ifup enp1s0f1 Insert the network cable (Cat5e) into one of the network ports of the network card (Intel EXPI9402PTBLK 82571GB) and the other end of the network cable into another powered network port, such as a switch, router, computer, etc.\nAt this time, enter the command to view the network port status\n1 ethtool enp1s0f0 As shown in the figure, Link detected: yes indicates that the found network port is enp1s0f0.\nOn the contrary, it shows Link detected: no, indicating the network port enp1s0f1 without a cable.\nDevice Location When directly passing a specified network port, ethtool can easily find the location of the network port in the PVE system.\nView all physical network cards and locations of the server\n1 lspci | grep -in \u0026#39;eth\u0026#39; View the location of the first network port enp1s0f0\n1 ethtool -i enp1s0f0 View the location of the second network port enp1s0f1\n1 ethtool -i enp1s0f1 As shown in the figure, the location of the first network port enp1s0f0 is 01:00.0, and the location of the second network port enp1s0f1 is 01:00.1.\nFinally, pass through the specified network card or network port in the virtual machine.\nConclusion: Using ethtool to identify multiple network ports of a network card is really convenient.\nFinally, a corresponding table can be made to facilitate future lookups.\nPhysical Network Card MAC Address PVE Device Name Device Location (for passthrough) VM Name 1st Port 00:24:81:7E:CE:CB enp1s0f0 01:00.0 LAN 2nd Port 00:24:81:7E:CE:CA enp1s0f1 01:00.1 WAN Reference: 圖哥-通用PVE AIO安装教程 Related: Proxmox VE 01 - 系統安裝篇 遷移 VMware ESXi 的 ova 文件到 Proxmox 7.0 PVE 的 LXC 容器系統安裝 CUPS 軟件，實現多平台共享的印表機 Proxmox VE 7 安裝Home Assistant虛擬機系統 Managing LXC in Proxmox Virtual Environment (PVE) Configuring VLANs on a Host for Proxmox VE ","permalink":"https://blog.kingtam.cf/posts/pve-network-port/","summary":"PVE (Proxmox VE) Multi-port Identification About: This is a post about network card (multiple ports) identification in the PVE system. Through the ethtool command, you can easily find the corresponding location of each network port.\nOperation Steps: Take Intel EXPI9402PTBLK 82571GB Network Adapter as an example\nInstall the ethtool command\n1 apt update \u0026amp;\u0026amp; apt install ethtool -y ethtool can be used to view network device driver parameters and hardware configuration.","title":"PVE (Proxmox VE) Multi-port Identification"},{"content":"About: WinSW is a utility that allows you to wrap and manage a Windows service for any executable.\nfrpc is a client for the frp (Fast Reverse Proxy) tool, which enables you to expose local servers to the internet.\nProcedure: To set up frpc as a Windows service using WinSW, follow these steps:\nDownload WinSW Download the latest release of WinSW from the releases page. Choose the appropriate executable for your system, either WinSW-x64.exe or WinSW-x86.exe. Rename WinSW executable Rename the downloaded WinSW executable to frpc-winsw.exe. This will be the service wrapper for the frpc executable. Create a configuration file Create a new XML configuration file named frpc-winsw.xml in the same directory as the frpc-winsw.exe. Add the following content to the file: 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;service\u0026gt; \u0026lt;id\u0026gt;frpc\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;frpc\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;frp client service managed by WinSW\u0026lt;/description\u0026gt; \u0026lt;executable\u0026gt;path\\to\\frpc.exe\u0026lt;/executable\u0026gt; \u0026lt;arguments\u0026gt;-c path\\to\\frpc.ini\u0026lt;/arguments\u0026gt; \u0026lt;log mode=\u0026#34;roll-by-size\u0026#34;\u0026gt; \u0026lt;sizeThreshold\u0026gt;10485760\u0026lt;/sizeThreshold\u0026gt; \u0026lt;keepFiles\u0026gt;3\u0026lt;/keepFiles\u0026gt; \u0026lt;/log\u0026gt; \u0026lt;onfailure action=\u0026#34;restart\u0026#34; /\u0026gt; \u0026lt;startmode\u0026gt;Automatic\u0026lt;/startmode\u0026gt; \u0026lt;/service\u0026gt; Replace path\\to\\frpc.exe with the actual path to your frpc.exe file. Replace path\\to\\frpc.ini with the actual path to your frpc.ini configuration file. Install the service Open a command prompt or PowerShell window with administrator privileges. Navigate to the directory containing frpc-winsw.exe and frpc-winsw.xml. Run the following command to install the service: 1 .\\frpc-winsw.exe install Installing service \u0026lsquo;frpc (frpc)\u0026rsquo;\u0026hellip; Service \u0026lsquo;frpc (frpc)\u0026rsquo; was installed successfully.\nStart the service After installing the service, start it by running the following command: 1 .\\frpc-winsw.exe start Service \u0026lsquo;frpc (frpc)\u0026rsquo; was refreshed successfully.\nStarting service \u0026lsquo;frpc (frpc)\u0026rsquo;\u0026hellip; Service \u0026lsquo;frpc (frpc)\u0026rsquo; started successfully.\nAlso, we can restart a Windows service from the command line (alternative)\n1 net stop frpc The frpc service is stopping. The frpc service was stopped successfully.\n1 net start frpc The frpc service is starting. The frpc service was started successfully.\nConclusion: frpc is set up as a Windows service and will automatically start on system boot. You can manage the service using the Services management console or by using the frpc-winsw.exe commands, such as stop, restart, and uninstall.\nReference: WinSW documentation frp documentation. ","permalink":"https://blog.kingtam.cf/posts/winsw-frpc/","summary":"About: WinSW is a utility that allows you to wrap and manage a Windows service for any executable.\nfrpc is a client for the frp (Fast Reverse Proxy) tool, which enables you to expose local servers to the internet.\nProcedure: To set up frpc as a Windows service using WinSW, follow these steps:\nDownload WinSW Download the latest release of WinSW from the releases page. Choose the appropriate executable for your system, either WinSW-x64.","title":"Use WINSW To Setup FRP As Windows Service"},{"content":"Installing CUPS on PVE\u0026rsquo;s LXC Container System Introduction: At home, I use a Canon LBP6030 USB printer connected to a Padavan system on a router (Youku1) to enable wireless printing. However, wireless printing can only be achieved on the Windows platform, and on systems such as macOS and IOS from Apple, it cannot be achieved, causing some inconvenience.\nI came across this post on SMZDM N1刷armbian變身打印服務器, which can install CUPS software as a printer server system, and thus the following content was recorded.\nTable of Contents: Requirements Installation of LXC container system (Debian) on PVE Passing through USB ports to LXC Installation of CUPS software and printer driver on LXC (Debian) Installation and printing test on multiple platform systems Installing the printer on Windows 10 Installing the printer on Windows 7 Installing the printer on macOS Installing the printer on Android Installing the printer on Linux (Deepin) Requirements: Platform that can install CUPS software\nSuch as armbian, ubuntu, centos, etc. I chose the Debian Linux platform.\nPrinter driver that supports the platform\nIf the driver that supports the platform can be found on OpenPrinting, this step can be ignored.\nReturn to Table of Contents\nInstallation of LXC container system (Debian) on PVE LXC provides an operating system-level virtualization environment that is installed on a system based on Linux.\nThe free PVE virtual server makes it easy to create a new Linux system (i.e., a canned system) with a shared kernel.\nDownload the CT template:\nCreate the LXC system:\nThe newly created LXC system does not need to be started yet.\nReturn to Table of Contents\nPassing through USB ports to LXC: Connect the USB port of the printer Canon LBP6030 to the USB port of the PVE host.\nUse lsusb to check the connected USB devices:\n1 lsusb We can see that Device 003 on Bus 001 is Canon.\nCheck thedevice number of Canon on the Bus 001:\n1 ls -al /dev/bus/usb/001 Allow LXC to access the USB device on PVE through cgroup.\n1 2 3 4 cat \u0026gt;\u0026gt; \u0026#39;/etc/pve/lxc/100.conf\u0026#39; \u0026lt;\u0026lt; EOF lxc.cgroup2.devices.allow: c 189:* rwm lxc.mount.entry: /dev/bus/usb/001 dev/bus/usb/001 none bind,optional,create=dir EOF The ID of LXC is 100, and the configuration file path is /etc/pve/lxc/100.conf.\nThe device inside 189:* rwm is allowed to be read, written, and mounted.\nMount the entire Bus 001 USB port. The advantage of this is that even if the device number changes due to unplugging the USB port of the printer multiple times, the mounting will not be affected.\nStart the newly created LXC container.\nCheck if it has been mounted in the LXC container\u0026rsquo;s Console:\n1 2 3 dmesg | grep -in \u0026#39;canon\u0026#39; 1617:[3489934.461195] usb 1-1: Manufacturer: Canon,Inc. 1837:[3494585.821378] usb 1-1: Manufacturer: Canon,Inc. Seeing Manufacturer: Canon, Inc. means that the USB printer has successfully connected to the LXC container.\nReturn to Table of Contents\nInstallation of CUPS software and printer driver on LXC (Debian) CUPS (Common UNIX Printing System) is a printing system supported in Fedora Core3 that mainly uses IPP (Internet Printing Protocol) to manage print jobs and queues, but also supports communication protocols such as LPD (Line Printer Daemon), SMB (Server Message Block), and AppSocket. From Baidu\nInstall the CUPS software:\n1 sudo apt update \u0026amp;\u0026amp; sudo apt install -y cups Enable remote access to CUPS:\n1 sudo cupsctl --remote-any Add the current user to the lpadmin group:\n1 sudo usermod -aG lpadmin $USER If the printer that is supported can be found on OpenPrinting, this step can be ignored.\nDownload and install the printer driver for Canon LBP6030:\n1 2 3 4 wget https://gdlp01.c-wss.com/gds/0/0100005950/10/linux-UFRIILT-drv-v500-uken-18.tar.gz \\ \u0026amp;\u0026amp; tar xzvf linux-UFRIILT-drv-v500-uken-18.tar.gz \\ \u0026amp;\u0026amp; sudo dpkg -i ./linux-UFRIILT-drv-v500-uken/64-bit_Driver/Debian/cnrdrvcups-ufr2lt-uk_5.00-1_amd64.deb \\ \u0026amp;\u0026amp; rm -rf linux-UFRIILT-drv-v500-uken linux-UFRIILT-drv-v500-uken-18.tar.gz Enter the following address in a browser: https://10.1.1.253:631/admin/\nThe IP address of the LXC system is: 10.1.1.253\nPrint test page:\nInstalling CUPS software completes the configuration of the printer server system.\nReturn to Table of Contents\nInstallation and testing of printer on multiple platforms After the deployment of CUPS software, multiple platforms can share printers. In the following example, I tested wireless printing functionality on Windows7, Windows10, macOS, iOS, and Android.\nInstalling Printer on Windows 10: Installing Printer through Search Manual Installation of Printer If the printer cannot be found through search or on a different network segment, manual installation of the printer is required.\nOpen the CUPS interface by entering http://10.1.1.253:631 in a browser and copy the path.\nPaste the path # Note that it cannot be https.\nReturn to Table of Contents\nInstalling Printer on Windows 7: Manually install the printer and prepare the corresponding Windows driver in advance.\nNote that the pasted path cannot be https.\nSelect the Windows driver that was prepared in advance.\nReturn to Table of Contents\nInstalling Printer on macOS: Return to Table of Contents\nInstalling Printer on Android: The tested Android device is the OnePlus 6, and the \u0026ldquo;Mopria Print Service\u0026rdquo; app is installed from the software store.\nReturn to Table of Contents\nInstalling Printer on Linux (Deepin): Return to Table of Contents\nConclusion: I believe that the most difficult part is the installation of the printer driver. If the manufacturer and model are found on OpenPrinting, the process should be relatively simple.\nThe advantage of using PVE\u0026rsquo;s LXCcontainer with CUPS installed is that it makes managing printers on a network much easier, especially for multiple users and devices. Overall, the installation process for printers on different operating systems varies, but with the right steps and information, it can be accomplished successfully.\nManually install printers using software like zero-tier, which can enable remote (cross-regional) printing. For example, you can directly access your home printer from work to print documents.\nReferences: USB Passthrough to an LXC (Proxmox)\nOpenPrinting\nN1刷armbian變身列印伺服器，支援全平臺無線列印@PC掃描\n","permalink":"https://blog.kingtam.cf/posts/pve-lxc-cups/","summary":"Installing CUPS on PVE\u0026rsquo;s LXC Container System Introduction: At home, I use a Canon LBP6030 USB printer connected to a Padavan system on a router (Youku1) to enable wireless printing. However, wireless printing can only be achieved on the Windows platform, and on systems such as macOS and IOS from Apple, it cannot be achieved, causing some inconvenience.\nI came across this post on SMZDM N1刷armbian變身打印服務器, which can install CUPS software as a printer server system, and thus the following content was recorded.","title":"Installing CUPS on PVE's LXC Container System"},{"content":"We will explore the syntax of managing LXC using PVE. Use commands that are commonly used by system administrators and cover the basics of creating, removing, and managing LXC in PVE.\nWhat\u0026rsquo;s LXC? LXC is a user space interface for the Linux kernel containment features. Through a powerful API and simple tools, it lets Linux users easily create and manage system or application containers.\nTemplate Image Creating an LXC in PVE is to download a template image. A template image is a preconfigured image of an operating system that can be used to create new LXC quickly.\nThe first step update container template database:\n1 pveam update List available images:\n1 pveam available Also filter the output:\n1 pveam available --section system The following command downloads a template image of an Ubuntu 22.04 operating system and saves it in the storage pool named \u0026ldquo;volume01\u0026rdquo;:\n1 pveam download volume01 vztmpl/ubuntu-22.04-standard_22.04-1_amd64.tar.zst Listing Template Images To see a list of all the template images stored in the storage pool named \u0026ldquo;volume01,\u0026rdquo; use the following command:\n1 pveam list volume01 NAME SIZE volume01:vztmpl/ubuntu-22.04-standard_22.04-1_amd64.tar.zst 123.81MB\nCreating an LXC Now that we have a template image, we can create a new LXC.\n1 2 3 4 5 6 7 pct create 403 volume01:vztmpl/ubuntu-22.04-standard_22.04-1_amd64.tar.zst \\ --storage volume01 --rootfs volume=volume01:16 \\ --ostype ubuntu --arch amd64 --password P@ssw0rd --unprivileged 1 \\ --cores 2 --memory 1024 --swap 0 \\ --hostname lxc-ubuntu \\ --net0 name=eth0,bridge=vmbr0,ip=dhcp,firewall=1,type=veth \\ --start true Configuring the LXC\nParameter Description pct create creates a new LXC with ID 403 and the image from the storage \u0026ldquo;volume01. --storage volume01 specifies the storage pool to be used for storing the LXC\u0026rsquo;s disks. --ostype ubuntu --arch amd64 specify the operating system and architecture of the LXC. --password P@ssw0rd --unprivileged 1 set the root password for the LXC and enable unprivileged mode. --cores 2 --memory 1024 --swap 0 specify the number of CPU cores, amount of memory and swap space allocated to the LXC. --hostname lxc-ubuntu This option sets the hostname of the LXC to \u0026ldquo;lxc-ubuntu\u0026rdquo;. --net0 name=eth0,bridge=vmbr0,ip=dhcp,firewall=1,type=veth the interface name set to eth0 and bridge to vmbr0 from the host, enable firewall and the network type value is: veth. --start true This option starts the LXC after it has been created. about veth\nThis type of network interface allows the LXC (container) or virtual machine to communicate with other devices on the network as if it were a physical device on the network. The veth interface also allows for network isolation between different LXC or virtual machines running on the same host system.\nLaunch a shell for the LXC Enter the container:\n1 pct enter 403 Update the system:\n1 apt update \u0026amp;\u0026amp; apt upgrade Install some packages:\n1 apt install -y curl git tmuxvim Set Vim as default editor:\n1 update-alternatives --set editor /usr/bin/vim.basic Create user:\n1 useradd -m user -s /bin/bash Switch to user:\n1 su - user Cleaning up Stop the LXC\n1 pct stop 401 Destroying an LXC\nTo remove an LXC from the system, use the following command:\n1 pct destroy 401 --purge This command destroys the LXC with ID 401 and removes its configuration files from the system.\nRemoving a Template Image If you want to remove a template image from the storage pool, use the following command:\n1 pveam remove volume01:vztmpl/vztmpl/ubuntu-22.04-standard_22.04-1_amd64.tar.zst Conclusion: We covered the basics of managing LXC in Proxmox Virtual Environment (PVE).\nLooked at how to download a template image, create an LXC, and configure it with various options. We also saw how to remove an LXC from the system.\nPVE offers many more commands and options for managing LXCs, and we encourage you to explore them further to get the most out of this powerful virtualization platform.\nReference: https://pve.proxmox.com/pve-docs/pct.1.html https://www.chucknemeth.com/proxmox/lxc/lxc-template Related: Proxmox VE 01 - 系統安裝篇 遷移 VMware ESXi 的 ova 文件到 Proxmox 7.0 PVE 的 LXC 容器系統安裝 CUPS 軟件，實現多平台共享的印表機 PVE (Proxmox VE) 多網口的識別 Proxmox VE 7 安裝Home Assistant虛擬機系統 Configuring VLANs on a Host for Proxmox VE Set up SmartDNS in Alpine Linux (LXC) ","permalink":"https://blog.kingtam.cf/posts/pve-lxc/","summary":"We will explore the syntax of managing LXC using PVE. Use commands that are commonly used by system administrators and cover the basics of creating, removing, and managing LXC in PVE.\nWhat\u0026rsquo;s LXC? LXC is a user space interface for the Linux kernel containment features. Through a powerful API and simple tools, it lets Linux users easily create and manage system or application containers.\nTemplate Image Creating an LXC in PVE is to download a template image.","title":"Managing LXC in Proxmox Virtual Environment (PVE)"},{"content":"Set up SmartDNS in Alpine Linux (LXC) SmartDNS is a local DNS server that retrieves DNS query results from multiple upstream DNS servers and delivers the fastest results to clients. It supports secure DNS protocols such as DoT (DNS over TLS) and DoH (DNS over HTTPS), providing enhanced privacy protection, avoiding DNS pollution, and improving network access speed. Additionally, SmartDNS supports high-performance ad filtering for an overall better browsing experience\nFeatures Multiple upstream DNS servers Return the fastest IP address Support for multiple query protocols Domain IP address specification Domain name high-performance rule filtering Linux/Windows multi-platform support Support IPV4, IPV6 dual stack DNS64 High performance, low resource consumption DNS domain forwarding Architecture Install SmartDNS on Alpine Linux (PVE LXC) Here is how to install SmartDNS on Alpine Linux running in a Proxmox VE LXC container\nDownload the latest version of SmartDNS from official website\n1 wget https://github.com/pymumu/smartdns/releases/download/Release42/smartdns.1.2023.05.07-1641.x86_64-linux-all.tar.gz Connecting to github.com (20.205.243.166:443) Connecting to objects.githubusercontent.com (185.199.111.133:443) saving to \u0026lsquo;smartdns.1.2023.05.07-1641.x86_64-linux-all.tar.gz\u0026rsquo; smartdns.1.2023.05.0 100% |******************************************************************************************| 1628k 0:00:00 ETA \u0026lsquo;smartdns.1.2023.05.07-1641.x86_64-linux-all.tar.gz\u0026rsquo; saved\nStart to install\n1 2 tar -zxf smartdns.1.2023.05.07-1641.x86_64-linux-all.tar.gz \u0026amp;\u0026amp; cd smartdns/ \u0026amp;\u0026amp; chmod +x ./install ./install -i created directory: \u0026lsquo;/etc/smartdns\u0026rsquo; \u0026lsquo;usr/sbin/smartdns\u0026rsquo; -\u0026gt; \u0026lsquo;/usr/sbin/smartdns\u0026rsquo; \u0026rsquo;etc/smartdns/smartdns.conf\u0026rsquo; -\u0026gt; \u0026lsquo;/etc/smartdns/smartdns.conf\u0026rsquo; install: can\u0026rsquo;t create \u0026lsquo;/etc/default/smartdns\u0026rsquo;: No such file or directory\ncopy the execute file to binaries with superuser (root) privileges directory\n1 cp ~/smartdns/usr/sbin/smartdns /usr/sbin/ backup original SmartDNS configuration file\n1 mv /etc/smartdns/smartdns.conf /etc/smartdns/smartdns.conf.bak create a new SmartDNS configuration file\nOfficial reference: https://pymumu.github.io/smartdns/en/config/basic-config/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 cat \u0026gt;\u0026gt; /etc/smartdns/smartdns.conf \u0026lt;\u0026lt; EOF server-name smartdns bind :53 bind-tcp :53 cache-size 3096 cache-file /tmp/smartdns.cache cache-persist yes tcp-idle-time 120 rr-ttl 600 rr-ttl-min 60 rr-ttl-max 600 rr-ttl-reply-max 60 local-ttl 60 prefetch-domain yes max-reply-ip-num 1 log-level info log-size 128K #-------dns----------- server-https https://cloudflare-dns.com/dns-query server-tls 1.1.1.1:853 server-tls 8.8.4.4:853 server-tls 9.9.9.9:853 server-tcp 114.114.114.114:53 server-tcp 223.5.5.5:53 server-tcp 180.76.76.76:53 server-tcp 202.99.160.68:53 server-tpc 8.8.4.4:53 server-tpc 9.9.9.9:53 #---------------- speed-check-mode ping,tcp:80,tcp:443 response-mode fastest-ip serve-expired yes force-AAAA-SOA yes EOF Disable DNS queries from UDHCP\n1 sed -i \u0026#39;s/^RESOLV_CONF/#RESOLV_CONF/\u0026#39; /usr/share/udhcpc/default.script Update the nameserver to localhost from /etc/resolv.conf in the PVE\u0026rsquo;s LXC\nEnable the service to start on boot\n1 2 3 echo \u0026#39;nohup /usr/sbin/smartdns -f -c /etc/smartdns/smartdns.conf \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#39; \u0026gt;\u0026gt; /etc/local.d/smartdns.start chmod +x /etc/local.d/smartdns.start rc-update add local Now Apply setting and functions by reboot\n1 reboot Create a systemd service file for SmartDNS (alternative) Create a new systemd service file at /etc/init.d/smartdns\n1 2 touch /etc/init.d/smartdns chmod +x /etc/init.d/smartdns Add the following content to the file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 cat \u0026gt;\u0026gt; /etc/init.d/smartdns \u0026lt;\u0026lt; EOF #!/sbin/openrc-run name=\u0026#34;SmartDNS\u0026#34; command=\u0026#34;/usr/sbin/smartdns\u0026#34; command_args=\u0026#34;-c /etc/smartdns/smartdns.conf\u0026#34; pidfile=\u0026#34;/var/run/smartdns.pid\u0026#34; depend() { need net after firewall } EOF Save and exit the text editor.\nEnable and start SmartDNS\n1 2 rc-update add smartdns default rc-service smartdns start Now, set to start on boot on your Alpine Linux system.\nAd Blocking by SmartDNS SmartDNS can block ads by returning SOA for the corresponding domain name. Official reference: https://pymumu.github.io/smartdns/en/config/ad-block/\nCreate a script to download the anti-ad-smartdns.conf file from the community URL\n1 2 3 4 cat \u0026gt;\u0026gt; /root/adblock-smartdns-conf.sh \u0026lt;\u0026lt; EOF #!/bin/bash wget https://github.com/privacy-protection-tools/anti-AD/blob/master/anti-ad-smartdns.conf -O /etc/smartdns/anti-ad-smartdns.conf EOF Make the script executable:\n1 chmod +x /root/adblock-smartdns-conf.sh Open the crontab editor:\n1 crontab -e Add the following line to the end of the file to run the script every day at 1:00 AM:\n1 0 1 * * * /root/adblock-smartdns-conf.sh Modify the /etc/smartdns/smartdns.conf file to include the above configuration file:\n1 conf-file /etc/smartdns/anti-ad-smartdns.conf Reference Linux - SmartDNS\nSmartDNS Releases\nAlpine linux系統安裝smartDNS伺服器實現DNS防污染快速查詢\nRelated Alpine Linux Installation\nApline Linux\u0026rsquo;s Package Management Tool\nAlpine Linux customizations\nAlpine Linux-based LXC with Docker support on a PVE host\nAlpine Linux as a DHCP and DNS Server\nAlpine Linux share the terminal over the web (ttyd)\nSet up SmartDNS in Alpine Linux (LXC)\n","permalink":"https://blog.kingtam.cf/posts/alpine-smartdns/","summary":"Set up SmartDNS in Alpine Linux (LXC) SmartDNS is a local DNS server that retrieves DNS query results from multiple upstream DNS servers and delivers the fastest results to clients. It supports secure DNS protocols such as DoT (DNS over TLS) and DoH (DNS over HTTPS), providing enhanced privacy protection, avoiding DNS pollution, and improving network access speed. Additionally, SmartDNS supports high-performance ad filtering for an overall better browsing experience","title":"Set up SmartDNS in Alpine Linux (LXC)"},{"content":"What is ttyd? What is ttyd? ttyd is a simple command-line program that allows you to share a terminal session over the web. It provides a web-based terminal interface for interacting with a Linux system, making it possible to access the system remotely from a web browser.\nInstall ttyd in Alpine Linux Install ttyd in Alpine Linux Open the terminal and type the following command to update the packages list:\n1 apk update Install the ttyd package by typing the following command:\n1 apk add ttyd Once the installation is complete, you can use the ttyd command to start the ttyd server.\nFor example, to start the ttyd server on port 7681, use the following command:\n1 ttyd -p 7681 /bin/sh This command will start the ttyd server and run the /bin/sh shell in it.\nYou can now access the ttyd server by opening a web browser and navigating to http://\u0026lt;ip_address\u0026gt;:7681.\nReplace \u0026lt;ip_address\u0026gt; with the IP address of the server where the ttyd server is running.\nThat\u0026rsquo;s it! You have now installed and started the ttyd server on Alpine Linux.\nMake ttyd start-up on boot Make ttyd start-up on boot Create a new file in the /etc/init.d/ directory using your preferred text editor. For example, you can use the following command to create a file named ttyd:\n1 vi /etc/init.d/ttyd Add the following content to the ttyd file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/sbin/openrc-run description=\u0026#34;ttyd service\u0026#34; command=\u0026#34;/usr/bin/ttyd -p 7681 login \u0026amp;\u0026#34; command_args=\u0026#34;\u0026#34; pidfile=\u0026#34;/run/ttyd.pid\u0026#34; depend() { after network } start_pre() { mkdir -p /run/ttyd } Option Description /usr/bin/ttyd Specifies the path to the ttyd binary. -p 7681 Specifies the port number that ttyd should listen on for incoming connections. In this case, it is set to 7681 (default). login Specifies the command to run after a user connects to ttyd. In this case, it is set to login, which starts a new login session. \u0026amp; Runs the command in the background, allowing the terminal to be used for other commands while ttyd continues to run. Creates a new service definition for ttyd, defining the command to run and the PID file location.\nAdjust the command line to use your desired options for ttyd.\nSave and exit the file.\nMake the ttyd script executable using the following command:\n1 chmod +x /etc/init.d/ttyd Add the ttyd service to the startup list using the following command:\n1 rc-update add ttyd service ttyd added to runlevel default This command adds the ttyd service to the default runlevel, so it will start up automatically on boot.\nThat\u0026rsquo;s it! You have now configured ttyd to start up on boot in Alpine Linux.\nConclusion Conclusion ttyd, which allows users to interact with the shell session in real-time using a web-based terminal interface. ttyd also is a useful tool for remote administration and troubleshooting of Linux systems.\nRelated Related OneCloud Gen1 - OpenWRT Install TTYD\nOneCloud Gen2 - Armbian Install TTYD\nAlpine Linux Installation\nApline Linux\u0026rsquo;s Package Management Tool\nAlpine Linux customizations\nAlpine Linux-based LXC with Docker support on a PVE host\nAlpine Linux as a DHCP and DNS Server\nAlpine Linux share the terminal over the web (ttyd)\nSet up SmartDNS in Alpine Linux (LXC)\n","permalink":"https://blog.kingtam.cf/posts/alpine-ttyd/","summary":"What is ttyd? What is ttyd? ttyd is a simple command-line program that allows you to share a terminal session over the web. It provides a web-based terminal interface for interacting with a Linux system, making it possible to access the system remotely from a web browser.\nInstall ttyd in Alpine Linux Install ttyd in Alpine Linux Open the terminal and type the following command to update the packages list:","title":"Alpine Linux share the terminal over the web (ttyd)"},{"content":" dnsmasq is a lightweight, easy-to-configure DHCP and DNS server. I\u0026rsquo;ll demonstrate how to set up dnsmasq as both a DHCP and DNS server on a Linux system.\nProcedure Procedure Network Card Configuration : Network Card Configuration 1 ip address The physical interface eth1 is used to set up DHCP and DNS services.\n1 2 3 4 5 6 7 8 cat \u0026gt;\u0026gt; /etc/network/interfaces \u0026lt;\u0026lt; EOF auto eth1 iface eth1 inet static address 192.168.0.1 network 192.168.0.0 netmark 255.255.255.0 broadcast 192.168.0.255 EOF Restart the networking to apply the settings.\n1 rc-service networking restart DNSMASQ Configuration : DNSMASQ Configuration Install dnsmasq:\n1 sudo apk add dnsmasq Configure dnsmasq:\nThe main configuration file for dnsmasq is /etc/dnsmasq.conf. Open this file with a text editor:\n1 sudo vi /etc/dnsmasq.conf Add or modify the following lines to configure dnsmasq as a DHCP and DNS server. Replace the placeholders with appropriate values for your network.\n1 2 3 4 5 6 7 8 # DHCP configuration dhcp-range=\u0026lt;start-IP\u0026gt;,\u0026lt;end-IP\u0026gt;,\u0026lt;netmask\u0026gt;,\u0026lt;lease-time\u0026gt; dhcp-option=option:router,\u0026lt;router-IP\u0026gt; dhcp-option=option:dns-server,\u0026lt;DNS-IP\u0026gt; # DNS configuration domain=\u0026lt;your-domain\u0026gt; local=/\u0026lt;your-domain\u0026gt;/ Also, can save the file in a folder (/etc/dnsmasq.d) which end in .conf .\nFor example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 cat \u0026gt;\u0026gt; /etc/dnsmasq.d/eth1.conf \u0026lt;\u0026lt; EOF # DHCP configuration dhcp-range=192.168.0.100,192.168.0.200,255.255.255.0,12h dhcp-option=option:router,192.168.0.1 dhcp-option=option:dns-server,192.168.0.1 # DNS configuration domain=local.lan local=/local.lan/ EOF Configure local DNS entries (optional):\nIf you want to add custom DNS entries for your local network, you can create a new file called /etc/hosts.dnsmasq and add the entries in the following format:\n1 \u0026lt;IP-address\u0026gt; \u0026lt;hostname\u0026gt;.\u0026lt;domain\u0026gt; \u0026lt;alias\u0026gt; For example:\n1 2 192.168.0.10 server.local.lan server 192.168.0.20 nas.local.lan nas Then, add the following line to /etc/dnsmasq.conf to use /etc/hosts.dnsmasq for local DNS resolution:\n1 addn-hosts=/etc/hosts.dnsmasq Start and enable dnsmasq:\n1 rc-service dnsmasq start /var/lib/misc/dnsmasq.leases: creating file /var/lib/misc/dnsmasq.leases: correcting owner Starting dnsmasq \u0026hellip; 1 rc-update add dnsmasq service dnsmasq added to runlevel default Perform client PC testing Perform client PC testing Clients should receive IP addresses and DNS settings automatically when they connect, and any custom local DNS entries you configured should resolve correctly.\n1 sudo rc-service networking restart Now, dnsmasq should be running as a DHCP and DNS server on network.\nRelated Related Alpine Linux Installation\nApline Linux\u0026rsquo;s Package Management Tool\nAlpine Linux customizations\nAlpine Linux-based LXC with Docker support on a PVE host\nAlpine Linux as a DHCP and DNS Server\nAlpine Linux share the terminal over the web (ttyd)\niPXE 網絡引導安裝\nSet up SmartDNS in Alpine Linux (LXC)\n","permalink":"https://blog.kingtam.cf/posts/alpine-dhcp-dns/","summary":"dnsmasq is a lightweight, easy-to-configure DHCP and DNS server. I\u0026rsquo;ll demonstrate how to set up dnsmasq as both a DHCP and DNS server on a Linux system.\nProcedure Procedure Network Card Configuration : Network Card Configuration 1 ip address The physical interface eth1 is used to set up DHCP and DNS services.\n1 2 3 4 5 6 7 8 cat \u0026gt;\u0026gt; /etc/network/interfaces \u0026lt;\u0026lt; EOF auto eth1 iface eth1 inet static address 192.","title":"Alpine Linux as a DHCP and DNS Server"},{"content":" Setting up an Alpine Linux-based Container (LXC) with Docker support on a Proxmox Virtual Environment (PVE) host.\nLightweight and secure: Alpine Linux is a lightweight and secure distribution of Linux that is ideal for use in containers. It has a small footprint and is designed to minimize attack surface, making it a good choice for running Docker containers. Flexibility: Using an LXC container allows you to run multiple instances of Docker on a single host, each with its own isolated environment and resources. Easy management: Proxmox VE provides a user-friendly web interface for managing LXC containers, making it easy to start, stop, and configure containers. Resource efficiency: Running Docker inside an LXC container allows you to maximize resource usage by sharing resources across multiple containers. This can lead to better performance and reduced resource usage compared to running Docker directly on the host. Modularity: Using Docker allows you to easily manage and deploy applications in a modular way, with each container running a specific service or application. This can simplify the management and maintenance of complex systems. Create a new LXC container with the specified configuration:\n1 2 3 4 5 6 7 pct create 302 volume01:vztmpl/alpine-3.17-default_20221129_amd64.tar.xz \\ --storage volume01 --rootfs volume=volume01:8 \\ --ostype alpine --arch amd64 --password P@ssw0rd --unprivileged 0 \\ --cores 2 --memory 1024 --swap 0 \\ --hostname lxc-alpine \\ --net0 name=eth0,bridge=vmbr0,ip=dhcp,firewall=1,type=veth \\ --start false Configuration Option Value Container ID 302 Template Alpine Linux Storage volume01 Root Filesystem Size volume=volume01:8 Operating System Type Alpine Architecture amd64 Password P@ssw0rd Container Privileges 0 means the container with privileged mode enabled CPU Cores 2 Memory 1024 Swap 0 Hostname lxc-alpine Network Settings name=eth0,bridge=vmbr0,ip=dhcp,firewall=1,type=veth Configure the LXC container to use an unconfined AppArmor profile and drop no capabilities:\n1 2 3 4 cat \u0026gt;\u0026gt; /etc/pve/lxc/302.conf \u0026lt;\u0026lt; EOF lxc.apparmor.profile: unconfined lxc.cap.drop: EOF Action Command Container config file Location /etc/pve/lxc/302.conf lxc.apparmor.profile: unconfined Disabling AppArmor confinement lxc.cap.drop: Retaining all capabilities for the container. Start the LXC container:\n1 pct start 302 Update and upgrade the container\u0026rsquo;s package repositories and installed packages:\n1 apk update \u0026amp;\u0026amp; apk upgrade This command updates the Alpine package repositories and upgrades the installed packages to their latest versions.\nInstall Docker and Docker Compose:\n1 apk add docker docker-compose This command installs Docker and Docker Compose, which are used to manage and deploy containerized applications.\nStart the Docker service and enable it to start automatically on boot:\n1 2 rc-service docker start rc-update add docker These commands start the Docker service and configure it to start automatically when the container boots.\nCreate the Docker configuration directory:\n1 mkdir -p /etc/docker Configure the Docker daemon with custom log and storage settings:\n1 2 3 4 5 6 7 8 9 10 cat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt; EOF { \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;20m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;vfs\u0026#34; } EOF Parameter Value File Location /etc/docker/daemon.json Logging Driver json-file Logging Driver Options max-size: 20m, max-file: 3 Storage Driver vfs Restart the Docker service to apply the configuration changes:\n1 rc-service docker restart Setting up an Alpine Linux-based Container (LXC) with Docker support on a Proxmox Virtual Environment (PVE) host provides a secure, flexible, and efficient way to run Docker containers.\n在 Alpine Linux 3 底下安裝 docker + docker-compose Alpine Linux Installation Apline Linux\u0026rsquo;s Package Management Tool Alpine Linux customizations Alpine Linux-based LXC with Docker support on a PVE host Alpine Linux as a DHCP and DNS Server Alpine Linux share the terminal over the web (ttyd) Managing LXC in Proxmox Virtual Environment (PVE) Set up SmartDNS in Alpine Linux (LXC) ","permalink":"https://blog.kingtam.cf/posts/alpine-lxc-docker/","summary":"Setting up an Alpine Linux-based Container (LXC) with Docker support on a Proxmox Virtual Environment (PVE) host.\nLightweight and secure: Alpine Linux is a lightweight and secure distribution of Linux that is ideal for use in containers. It has a small footprint and is designed to minimize attack surface, making it a good choice for running Docker containers. Flexibility: Using an LXC container allows you to run multiple instances of Docker on a single host, each with its own isolated environment and resources.","title":"Alpine Linux-based LXC with Docker support on a PVE host"},{"content":" One of the benefits of using Alpine Linux is its flexibility and customizability, which allows users to tailor the system to their specific needs.\nSetting the timezone Check the current timezone\n1 date Timezone setting\n1 setup-timezone Which timezone are you in? (\u0026rsquo;?\u0026rsquo; for list) [UTC] Asia/Hong_Kong\nSuppose you want to use the Asia/ timezone and Hong_Kong as the sub-timezone of \u0026lsquo;Asia/\u0026rsquo;. You can input \u0026lsquo;?\u0026rsquo; to list the timezones to choose from.\nCheck the Date\n1 date Make a dynamic MOTD MOTD stands for \u0026ldquo;Message of the Day\u0026rdquo; in Linux. It is a customizable message that is displayed to users when they log in to the system.\nCreate a crond script to dynamic create an motd message to users\n1 2 3 4 rc-service crond start \u0026amp;\u0026amp; rc-update add crond vi /etc/periodic/15min/motd chmod a+x /etc/periodic/15min/motd run-parts --test /etc/periodic/15min Command Description rc-service crond start Starts the crond service, which runs scheduled tasks on the system. rc-update add crond Adds the crond service to the default runlevel, ensuring that it starts automatically on boot. vi /etc/periodic/15min/motd Use the Vi text editor and creates a new shell script at /etc/periodic/15min/motd. This script is executed every 15 minutes to update the MOTD. chmod a+x /etc/periodic/15min/motd Sets the execute permission for the motd script, allowing the system to run it as a periodic task. run-parts --test /etc/periodic/15min Tests the /etc/periodic/15min directory for executable scripts and prints a list of the scripts that would be executed by the system\u0026rsquo;s periodic task scheduler. Contents of /etc/periodic/15min/motd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #!/bin/sh #. /etc/os-release PRETTY_NAME=`awk -F= \u0026#39;$1==\u0026#34;PRETTY_NAME\u0026#34; { print $2 ;}\u0026#39; /etc/os-release | tr -d \u0026#39;\u0026#34;\u0026#39;` VERSION_ID=`awk -F= \u0026#39;$1==\u0026#34;VERSION_ID\u0026#34; { print $2 ;}\u0026#39; /etc/os-release` UPTIME_DAYS=$(expr `cat /proc/uptime | cut -d \u0026#39;.\u0026#39; -f1` % 31556926 / 86400) UPTIME_HOURS=$(expr `cat /proc/uptime | cut -d \u0026#39;.\u0026#39; -f1` % 31556926 % 86400 / 3600) UPTIME_MINUTES=$(expr `cat /proc/uptime | cut -d \u0026#39;.\u0026#39; -f1` % 31556926 % 86400 % 3600 / 60) cat \u0026gt; /etc/motd \u0026lt;\u0026lt; EOF %+++++++++++++++++++++++++++++++ SERVER INFO ++++++++++++++++++++++++++++++++% % % Name: `hostname` Uptime: $UPTIME_DAYS days, $UPTIME_HOURS hours, $UPTIME_MINUTES minutes CPU: `cat /proc/cpuinfo | grep \u0026#39;model name\u0026#39; | head -1 | cut -d\u0026#39;:\u0026#39; -f2` Memory: `free -m | head -n 2 | tail -n 1 | awk {\u0026#39;print $2\u0026#39;}`M Swap: `free -m | tail -n 1 | awk {\u0026#39;print $2\u0026#39;}`M Disk: `df -h / | awk \u0026#39;{ a = $2 } END { print a }\u0026#39;` Kernel: `uname -r` Distro: $PRETTY_NAME Version $VERSION_ID CPU Load: `cat /proc/loadavg | awk \u0026#39;{print $1 \u0026#34;, \u0026#34; $2 \u0026#34;, \u0026#34; $3}\u0026#39;` Free Memory: `free -m | head -n 2 | tail -n 1 | awk {\u0026#39;print $4\u0026#39;}`M Free Swap: `free -m | tail -n 1 | awk {\u0026#39;print $4\u0026#39;}`M Free Disk: `df -h / | awk \u0026#39;{ a = $2 } END { print a }\u0026#39;` eth0 Address: `ifconfig eth0 | grep \u0026#34;inet addr\u0026#34; | awk -F: \u0026#39;{print $2}\u0026#39; | awk \u0026#39;{print $1}\u0026#39;` % % %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++% EOF This is the result:\nChanging To The Bash Shell Bash is a popular command shell in the Linux community, and many users prefer it over the default shell in Alpine Linux, which is ash. Changing to the Bash shell in Alpine Linux is a simple process that can greatly enhance our productivity and efficiency when working with the Linux system.\nAlpine Linux uses Ash by default as the shell, but I prefer to use Bash as my Linux shell. To install Bash in Alpine Linux and make it the default shell, follow these steps:\nInstall Bash:\n1 apk add bash bash-doc bash-completion Change the default shell for your user:\n1 sed -i \u0026#39;s/ash/bash/\u0026#39; /etc/passwd Verify the change by checking the first line of the /etc/passwd file:\n1 cat /etc/passwd | head -n 1 It should display /bin/bash.\nCustomize the Bash shell. We can configure the Bash shell liking by adding your aliases and settings. Here is an example of customization:\n1 2 3 4 5 6 7 8 9 10 11 cat \u0026gt;\u0026gt; ~/.bash_profile \u0026lt;\u0026lt; EOF alias update=\u0026#39;apk update \u0026amp;\u0026amp; apk upgrade\u0026#39; export HISTTIMEFORMAT=\u0026#34;%d/%m/%y %T \u0026#34; export PS1=\u0026#39;\\u@\\h:\\W \\$ \u0026#39; alias l=\u0026#39;ls -CF\u0026#39; alias la=\u0026#39;ls -A\u0026#39; alias ll=\u0026#39;ls -alhF\u0026#39; alias ls=\u0026#39;ls --color=auto\u0026#39; source /etc/profile.d/bash_completion.sh export PS1=\u0026#34;\\[\\e[31m\\][\\[\\e[m\\]\\[\\e[38;5;172m\\]\\u\\[\\e[m\\]@\\[\\e[38;5;153m\\]\\h\\[\\e[m\\] \\[\\e[38;5;214m\\]\\W\\[\\e[m\\]\\[\\e[31m\\]]\\[\\e[m\\]\\\\$ \u0026#34; EOF This customizes the Bash shell with aliases for common commands, a colored prompt, and auto-completion using the bash_completion.sh script.\nNeoVim and Vim plugins Install in Alpine Linux NeoVim is a popular text editor that is designed to be more extensible and customizable than traditional editors like Vim. It offers many features that make it an excellent choice for developers and testers.\nTo install NeoVim and Vim plugins in Alpine Linux, follow these steps:\nInstall NeoVim using the apk package manager:\n1 apk add neovim curl git Install Vim plugins using the Vim plugin manager, such as Vim-Plug. First, download and install Vim-Plug:\n1 2 curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim Create the NeoVim configuration file:\n1 2 mkdir -p ~/.config/nvim touch ~/.config/nvim/init.vim Add the following lines to your init.vim file to set up Vim-Plug and install plugins:\n1 2 3 4 5 6 7 call plug#begin(\u0026#39;~/.local/share/nvim/plugged\u0026#39;) Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;tpope/vim-commentary\u0026#39; Plug \u0026#39;scrooloose/nerdtree\u0026#39; Plug \u0026#39;joshdick/onedark.vim\u0026#39; call plug#end() Save and exit the init.vim file.\nOpen NeoVim:\n1 nvim Install the Vim plugins using the following command:\n1 :PlugInstall This will download and install the plugins specified in your init.vim file.\nSetting up a new user Installing sudo and assigning sudo privileges to a new user in Alpine Linux can greatly enhance your system\u0026rsquo;s security and flexibility.\nInstall sudo using the apk package manager:\n1 apk add sudo (1/1) Installing sudo (1.9.12_p2-r1) Executing busybox-1.35.0-r29.trigger\nCreate a new user:\n1 NEWUSER=\u0026#39;user\u0026#39; \u0026lsquo;user\u0026rsquo; as your UserName\n1 adduser -g \u0026#34;${NEWUSER}\u0026#34; $NEWUSER -s /bin/bash Changing password for user New password: Bad password: too weak Retype password: passwd: password for user changed by root\nalso the new user using a bash shell as default shell and\nAdd the new user to the sudo group:\n1 echo \u0026#34;$NEWUSER ALL=(ALL) ALL\u0026#34; \u0026gt; /etc/sudoers.d/$NEWUSER \u0026amp;\u0026amp; chmod 0440 /etc/sudoers.d/$NEWUSER create a username file in the sudoers folder to allow the new user to use sudo:\nOnce you have completed these steps, the new user can use the sudo command to elevate their privileges when necessary. To use the sudo command, the user should prefix the command they want to run with \u0026ldquo;sudo\u0026rdquo;, like this:\n1 sudo apk update For example, if the new user wants to install a new package using apk, they can use the following command:\n1 sudo apk add \u0026lt;package_name\u0026gt; This will prompt the user to enter their password before allowing the command to run with elevated privileges.\nSSH key authentication to login Update the package and Install OpenSSH:\n1 2 3 4 apk update \u0026amp;\u0026amp; apk add openssh ``` Once the installation is complete, start the OpenSSH service: /etc/init.d/sshd start\n1 2 Enable the service to start automatically at boot: rc-update add sshd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026gt; Using SSH key authentication to log in to Alpine Linux without a password is a secure and convenient way to access your system remotely. To use SSH key authentication to login to Alpine Linux without a password, follow these steps: ### Local server setting (as a client) Generate an SSH key pair on your local machine if you haven\u0026#39;t already done so: ```bash ssh-keygen Copy the public key to the remote server (Alpine Linux) using the ssh-copy-id command:\n1 ssh-copy-id \u0026lt;username\u0026gt;@\u0026lt;server_ip_address\u0026gt; Enter your user password when prompted.\nSSH into the remote server:\n1 ssh \u0026lt;username\u0026gt;@\u0026lt;server_ip_address\u0026gt; You should now be able to log in to the remote server without being prompted for your password.\nRemote server setting (as server) Disabling Password Authentication on your Server\n1 sudo -i 1 echo \u0026#34;PasswordAuthentication no\u0026#34; \u0026gt;\u0026gt; /etc/ssh/sshd_config 1 rc-service sshd restart Caching service dependencies \u0026hellip; [ ok ] Stopping sshd \u0026hellip; [ ok ] Starting sshd \u0026hellip; [ ok ] Enable unprivileged users to use ICMP (Ping) To fix the error \u0026ldquo;unprivileged ping is disabled, please enable by setting net.ipv4.ping_group_range\u0026rdquo; when trying to use the ping command, it means that non-root users are not allowed to use the ping command.\nAdd a new config file:\n1 echo \u0026#39;net.ipv4.ping_group_range = 0 65534\u0026#39; \u0026gt;\u0026gt; /etc/sysctl.d/99-allow-ping.conf Apply the changes:\n1 sysctl -p Conclusion Alpine Linux is a highly customizable distribution of Linux that offers a wide range of customizations to enhance your experience with the system. By following the customizations outlined in this post, We can tailor Alpine Linux to our specific needs and preferences, making it a powerful and flexible tool for development and system administration.\nReference Alpine Linux Installation How to install bash shell in Alpine Linux Setting up a new user How To Configure SSH Key-Based Authentication on a Linux Server Related Alpine Linux Installation Apline Linux\u0026rsquo;s Package Management Tool Alpine Linux customizations Alpine Linux-based LXC with Docker support on a PVE host Alpine Linux as a DHCP and DNS Server Alpine Linux share the terminal over the web (ttyd) Set up SmartDNS in Alpine Linux (LXC) ","permalink":"https://blog.kingtam.cf/posts/alpine-customization/","summary":"One of the benefits of using Alpine Linux is its flexibility and customizability, which allows users to tailor the system to their specific needs.\nSetting the timezone Check the current timezone\n1 date Timezone setting\n1 setup-timezone Which timezone are you in? (\u0026rsquo;?\u0026rsquo; for list) [UTC] Asia/Hong_Kong\nSuppose you want to use the Asia/ timezone and Hong_Kong as the sub-timezone of \u0026lsquo;Asia/\u0026rsquo;. You can input \u0026lsquo;?\u0026rsquo; to list the timezones to choose from.","title":"Alpine Linux Customizations"},{"content":"About The package management tool used in Alpine Linux is apk. apk is a fast, lightweight, and efficient package management tool that has the following features:\nNative support for cross-compilation and cross-platform installation. Automatic handling of dependencies when installing and uninstalling packages. Support for multiple repositories, including official repositories, community repositories, and personal repositories. Simple command-line interface that allows users to perform various operations such as search, install, upgrade, and uninstall. Support for virtual packages that enables users to install a set of related packages by installing a single virtual package. How to Use Here are some basic commands for using the apk package manager in Alpine Linux:\n-Update the package index:\n1 apk update -Search for a package:\n1 apk search \u0026lt;package_name\u0026gt; -Install a package:\n1 apk add \u0026lt;package_name\u0026gt; -Remove a package:\n1 apk del \u0026lt;package_name\u0026gt; -View information about a package:\n1 apk info \u0026lt;package_name\u0026gt; -List all installed packages:\n1 apk info -vv | less -Upgrade all installed packages:\n1 apk upgrade -Upgrade a specific package:\n1 apk upgrade \u0026lt;package_name\u0026gt; -List the contents of a package:\n1 apk info -L \u0026lt;package_name\u0026gt; -Show the dependencies of a package:\n1 apk info -R \u0026lt;package_name\u0026gt; Enable community repositories Edit the file /etc/apk/repositories and uncomment a line that points to the \u0026ldquo;community\u0026rdquo; directory.\nUsing Examples To install neovim in Alpine Linux using the apk\n1 apk add neovim (1/11) Installing libintl (0.21.1-r1) (2/11) Installing libgcc (12.2.1_git20220924-r4) (3/11) Installing luajit (2.1_p20210510-r3) (4/11) Installing libuv (1.44.2-r0) (5/11) Installing libluv (1.44.2.1-r0) (6/11) Installing msgpack-c (4.0.0-r0) (7/11) Installing unibilium (2.1.1-r0) (8/11) Installing libtermkey (0.22-r0) (9/11) Installing tree-sitter (0.20.7-r0) (10/11) Installing libvterm (0.3-r0) (11/11) Installing neovim (0.8.1-r0) Executing busybox-1.35.0-r29.trigger OK: 138 MiB in 71 packages\nTo install multiple applications with apk in Alpine Linux\n1 apk add bash bash-doc bash-completion (1/7) Installing readline (8.2.0-r0) (2/7) Installing bash (5.2.15-r0) Executing bash-5.2.15-r0.post-install (3/7) Installing pkgconf (1.9.4-r0) (4/7) Installing bash-completion (2.11-r4) (5/7) Installing openrc-bash-completion (0.45.2-r7) (6/7) Installing bash-doc (5.2.15-r0) (7/7) Installing kmod-bash-completion (30-r1) Executing busybox-1.35.0-r29.trigger OK: 145 MiB in 78 packages\nThe \u0026ldquo;apk search\u0026rdquo; command in Alpine Linux\n1 apk search docker This will display a list of packages related to Docker.\nTo uninstall or remove an application in Alpine Linux using apk\nList all installed packages and find out the application as you want to remove.\n1 apk list | grep \u0026#39;neovim\u0026#39; Use the \u0026ldquo;apk del\u0026rdquo; command followed by the name of the package to remove it\n1 apk del neovim (1/11) Purging neovim (0.8.1-r0) (2/11) Purging libintl (0.21.1-r1) (3/11) Purging luajit (2.1_p20210510-r3) (4/11) Purging libgcc (12.2.1_git20220924-r4) (5/11) Purging libluv (1.44.2.1-r0) (6/11) Purging libuv (1.44.2-r0) (7/11) Purging msgpack-c (4.0.0-r0) (8/11) Purging libtermkey (0.22-r0) (9/11) Purging unibilium (2.1.1-r0) (10/11) Purging tree-sitter (0.20.7-r0) (11/11) Purging libvterm (0.3-r0) Executing busybox-1.35.0-r29.trigger OK: 123 MiB in 67 packages\nOverall apk is a fast, lightweight, and efficient package management tool that makes it easy for users to manage and maintain software packages in Alpine Linux.\nRelated Alpine Linux Installation\nApline Linux\u0026rsquo;s Package Management Tool\nAlpine Linux customizations\nAlpine Linux-based LXC with Docker support on a PVE host\nAlpine Linux as a DHCP and DNS Server\nAlpine Linux share the terminal over the web (ttyd)\nSet up SmartDNS in Alpine Linux (LXC)\n","permalink":"https://blog.kingtam.cf/posts/alpine-apk/","summary":"About The package management tool used in Alpine Linux is apk. apk is a fast, lightweight, and efficient package management tool that has the following features:\nNative support for cross-compilation and cross-platform installation. Automatic handling of dependencies when installing and uninstalling packages. Support for multiple repositories, including official repositories, community repositories, and personal repositories. Simple command-line interface that allows users to perform various operations such as search, install, upgrade, and uninstall.","title":"Alpine Linux Package Management Tool"},{"content":"Why Alpine Linux Alpine Linux is a lightweight, security-focused, rolling release distribution with a fast and efficient package manager. It is highly customizable and compatible with a wide range of hardware architectures, making it suitable for use in a variety of environments.\nPreparation Download the Alpine Linux ISO image file from the official website: https://alpinelinux.org/downloads/ Write the ISO image file to a USB drive using a tool such as Rufus or Etcher. Insert the USB drive into your computer and boot from it. This can usually be done by pressing a key (such as F12 or Del) during the startup process to enter the boot menu, then selecting the USB drive as the boot device. Procedure of Install Once Alpine Linux has booted, you will see a command-line interface. Type the login name \u0026ldquo;root\u0026rdquo; and press Enter.\nSetup the system with command “setup-alpine”.\nFollow the prompts to select the keyboard layout (or press enter to select none), and type system hostname (e.g. alpine)\nConstantly choosing default settings, such as interface eth0, using DHCP to ask for an IP address.\nEnter it twice to change the root password, and select the appropriate time zone for your location or enter it manually (e.g. Asia/Hong_Kong).\nChoose the fastest repository (e.g. 1)\nType a username or press enter to choose no.\nSelect openssh as ssh server.\nNext, prompt to select Available disks. Enter a disk name (such as sda) to use for installing the system.\nEnter the name sys as the base system then type y to confirm erasing the disk and starting the formatting and base system installation process.\nFinally, you will be prompted to reboot the system. Remove the USB drive and type reboot to restart the system.\nCongratulations, Alpine Linux is successfully installed! Related Alpine Linux Installation\nApline Linux\u0026rsquo;s Package Management Tool\nAlpine Linux customizations\nAlpine Linux-based LXC with Docker support on a PVE host\nAlpine Linux as a DHCP and DNS Server\nAlpine Linux share the terminal over the web (ttyd)\nSet up SmartDNS in Alpine Linux (LXC)\n","permalink":"https://blog.kingtam.cf/posts/alpine-installation/","summary":"Why Alpine Linux Alpine Linux is a lightweight, security-focused, rolling release distribution with a fast and efficient package manager. It is highly customizable and compatible with a wide range of hardware architectures, making it suitable for use in a variety of environments.\nPreparation Download the Alpine Linux ISO image file from the official website: https://alpinelinux.org/downloads/ Write the ISO image file to a USB drive using a tool such as Rufus or Etcher.","title":"Alpine Installation"}]